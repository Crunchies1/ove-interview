{"ast":null,"code":"import { fetchHistoricData } from '../pages/api/actions.js'; // State is represented by a list of key-objects\n// key: SYMBOL\n// object: {\n//   PRICE: float\n//   INDICATOR: int\n//   CHANGE: float\n//   GRAPH: Array of x-axis and y-axis\n// }\n// ====== HELPER FUNCTIONS FOR FETCH DATA ======\n// eslint-disable-next-line no-extend-native\n\nDate.prototype.prevDays = function (days) {\n  const date = new Date(this.valueOf()); // Return the current date minus days\n\n  date.setDate(date.getDate() - days);\n  return date;\n}; // Returns the array of dates we are looking through\n\n\nfunction getDates(startDate, stopDate) {\n  const dateArray = [];\n  let currentDate = startDate;\n\n  while (currentDate >= stopDate) {\n    // Converts date string into YYYY-MM-DD format\n    let date = currentDate.toUTCString().split(', ')[1];\n    date = new Date(date).toISOString().split('T')[0];\n    dateArray.push(date);\n    currentDate = currentDate.prevDays(1);\n  }\n\n  return dateArray;\n} // This function adds new entries to the state map following the sample state\n\n\nfunction addToState(array, key, value, date) {\n  array[key] = {\n    price: value.toPrecision(6),\n    indicator: null,\n    change: null,\n    graph: [[date], [value]]\n  };\n} // This function adds values to the graph array in the current state map\n\n\nfunction addToGraph(array, key, value, date) {\n  array[key].graph[0].unshift(date);\n  array[key].graph[1].unshift(value);\n} // This function calculates the change in percentage from the first day of tracking to the last\n\n\nfunction calculateChange(array, key) {\n  // Obtain the current value and the latest recorded value\n  const curVal = array[key].graph[1][array[key].graph[1].length - 1];\n  const prevVal = array[key].graph[1][0]; // Calculate percentage change and set array values\n\n  if (curVal > prevVal) {\n    array[key].indicator = 1;\n    array[key].change = '+' + (100 * (curVal - prevVal) / prevVal).toFixed(2) + '%';\n  } else if (curVal === prevVal) {\n    array[key].indicator = 0;\n    array[key].change = 0 .toFixed(2) + '%';\n  } else {\n    array[key].indicator = -1;\n    array[key].change = (100 * (curVal - prevVal) / prevVal).toFixed(2) + '%';\n  }\n} // =============================================\n// Calls API to fetch and cache the required data\n\n\nasync function fetchData(base, timeframe) {\n  // const data = await fetchLatestData()\n  // const cacheId = data.base + data.date\n  // Obtain the dates of the previous 7 days in yy-mm-dd format\n  const dateArray = getDates(new Date(), new Date().prevDays(timeframe)); // For each value in the data array, send an HTTP request\n\n  await Promise.all(dateArray.map(async date => {\n    try {\n      // Check to see if the data we require has already been cached\n      let pastData;\n\n      if (window.localStorage.getItem(base + date) === null) {\n        // Otherwise, simply fetch the data from ratesapi.io\n        pastData = await fetchHistoricData(date, base); // Cache the fetched data\n\n        const cacheId = pastData.base + date;\n        window.localStorage.setItem(cacheId, JSON.stringify(pastData.rates));\n      }\n    } catch (error) {\n      console.log('error' + error);\n    }\n  })); // Return the array of dates used\n\n  return dateArray;\n} // Function to generate the index state based on the dates given\n\n\nfunction genState(dateArray, base) {\n  // Initialise the state array\n  const rateData = {}; // Loop through the dates in the date array\n\n  for (let i = 0; i < dateArray.length; i++) {\n    // Retrieve the rates for each date using current base\n    const date = dateArray[i];\n    let rates = window.localStorage.getItem(base + date); // Generate state using day 1 rates\n\n    if (i === 0) {\n      rateData[base] = {\n        price: 1,\n        indicator: null,\n        change: null,\n        graph: null\n      };\n    } // Loop through each rate\n\n\n    rates = JSON.parse(rates);\n\n    for (const key of Object.keys(rates)) {\n      if (key !== base) {\n        if (i === 0) {\n          // Generate state using day 1 rates\n          addToState(rateData, key, rates[key], date);\n        } else if (i < dateArray.length - 1) {\n          // Add the rate data to the graphs\n          addToGraph(rateData, key, rates[key], date);\n        } else {\n          // Lastly, add the rate data to the graphs then calculate the final\n          // indicator and change values\n          addToGraph(rateData, key, rates[key], date);\n          calculateChange(rateData, key);\n        }\n      }\n    }\n  }\n\n  return rateData;\n}\n\nexport const FETCH_DATA = 'FETCH_DATA'; // Implemented as if it can be extended in the future\n\nexport const calculator = async (action, base, timeframe) => {\n  switch (action) {\n    case FETCH_DATA:\n      {\n        const dA = await fetchData(base, timeframe);\n        const rD = genState(dA, base);\n        return rD;\n      }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}