{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/HP/Documents/ove-interview/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/HP/Documents/ove-interview/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { fetchHistoricData } from '../api/actions.js'; // State is represented by a list of key-objects\n// key: SYMBOL\n// object: {\n//   PRICE: float\n//   INDICATOR: int\n//   CHANGE: float\n//   GRAPH: Array of x-axis and y-axis\n// }\n// ====== HELPER FUNCTIONS FOR FETCH DATA ======\n// eslint-disable-next-line no-extend-native\n\nDate.prototype.prevDays = function (days) {\n  var date = new Date(this.valueOf()); // Return the current date minus days\n\n  date.setDate(date.getDate() - days);\n  return date;\n}; // Returns the array of dates we are looking through\n\n\nfunction getDates(startDate, stopDate) {\n  var dateArray = [];\n  var currentDate = startDate;\n\n  while (currentDate >= stopDate) {\n    // Converts date string into YYYY-MM-DD format\n    var date = currentDate.toUTCString().split(', ')[1];\n    date = new Date(date).toISOString().split('T')[0];\n    dateArray.push(date);\n    currentDate = currentDate.prevDays(1);\n  }\n\n  return dateArray;\n} // This function adds new entries to the state map following the sample state\n\n\nfunction addToState(array, key, value, date) {\n  array[key] = {\n    price: value.toPrecision(6),\n    indicator: null,\n    change: null,\n    graph: [[date], [value]]\n  };\n} // This function adds values to the graph array in the current state map\n\n\nfunction addToGraph(array, key, value, date) {\n  array[key].graph[0].unshift(date);\n  array[key].graph[1].unshift(value);\n} // This function calculates the change in percentage from the first day of tracking to the last\n\n\nfunction calculateChange(array, key) {\n  // Obtain the current value and the latest recorded value\n  var curVal = array[key].graph[1][array[key].graph[1].length - 1];\n  var prevVal = array[key].graph[1][0]; // Calculate percentage change and set array values\n\n  if (curVal > prevVal) {\n    array[key].indicator = 1;\n    array[key].change = '+' + (100 * (curVal - prevVal) / prevVal).toFixed(2) + '%';\n  } else if (curVal === prevVal) {\n    array[key].indicator = 0;\n    array[key].change = 0 .toFixed(2) + '%';\n  } else {\n    array[key].indicator = -1;\n    array[key].change = (100 * (curVal - prevVal) / prevVal).toFixed(2) + '%';\n  }\n} // =============================================\n// Calls API to fetch and cache the required data\n\n\nfunction fetchData(_x, _x2) {\n  return _fetchData.apply(this, arguments);\n} // Function to generate the index state based on the dates given\n\n\nfunction _fetchData() {\n  _fetchData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(base, timeframe) {\n    var dateArray;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            // const data = await fetchLatestData()\n            // const cacheId = data.base + data.date\n            // Obtain the dates of the previous 7 days in yy-mm-dd format\n            dateArray = getDates(new Date(), new Date().prevDays(timeframe)); // For each value in the data array, send an HTTP request\n\n            _context3.next = 3;\n            return Promise.all(dateArray.map( /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(date) {\n                var pastData, cacheId;\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.prev = 0;\n\n                        if (!(window.localStorage.getItem(base + date) === null)) {\n                          _context2.next = 7;\n                          break;\n                        }\n\n                        _context2.next = 4;\n                        return fetchHistoricData(date, base);\n\n                      case 4:\n                        pastData = _context2.sent;\n                        // Cache the fetched data\n                        cacheId = pastData.base + date;\n                        window.localStorage.setItem(cacheId, JSON.stringify(pastData.rates));\n\n                      case 7:\n                        _context2.next = 12;\n                        break;\n\n                      case 9:\n                        _context2.prev = 9;\n                        _context2.t0 = _context2[\"catch\"](0);\n                        console.log('error' + _context2.t0);\n\n                      case 12:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2, null, [[0, 9]]);\n              }));\n\n              return function (_x6) {\n                return _ref2.apply(this, arguments);\n              };\n            }()));\n\n          case 3:\n            return _context3.abrupt(\"return\", dateArray);\n\n          case 4:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _fetchData.apply(this, arguments);\n}\n\nfunction genState(dateArray, base) {\n  // Initialise the state array\n  var rateData = {}; // Loop through the dates in the date array\n\n  for (var i = 0; i < dateArray.length; i++) {\n    // Retrieve the rates for each date using current base\n    var date = dateArray[i];\n    var rates = window.localStorage.getItem(base + date); // Generate state using day 1 rates\n\n    if (i === 0) {\n      rateData[base] = {\n        price: 1,\n        indicator: null,\n        change: null,\n        graph: null\n      };\n    } // Loop through each rate\n\n\n    rates = JSON.parse(rates);\n\n    for (var _i = 0, _Object$keys = Object.keys(rates); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n\n      if (key !== base) {\n        if (i === 0) {\n          // Generate state using day 1 rates\n          addToState(rateData, key, rates[key], date);\n        } else if (i < dateArray.length - 1) {\n          // Add the rate data to the graphs\n          addToGraph(rateData, key, rates[key], date);\n        } else {\n          // Lastly, add the rate data to the graphs then calculate the final\n          // indicator and change values\n          addToGraph(rateData, key, rates[key], date);\n          calculateChange(rateData, key);\n        }\n      }\n    }\n  }\n\n  return rateData;\n}\n\nexport var FETCH_DATA = 'FETCH_DATA'; // Implemented as if it can be extended in the future\n\nexport var calculator = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(action, base, timeframe) {\n    var dA, rD;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.t0 = action;\n            _context.next = _context.t0 === FETCH_DATA ? 3 : 8;\n            break;\n\n          case 3:\n            _context.next = 5;\n            return fetchData(base, timeframe);\n\n          case 5:\n            dA = _context.sent;\n            rD = genState(dA, base);\n            return _context.abrupt(\"return\", rD);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function calculator(_x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"module"}